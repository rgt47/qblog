[
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html",
    "href": "posts/share_R_code_via_docker_p25/index.html",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "",
    "text": "Reproducibility is key to conducting professional data analysis, yet in practice, achieving it consistently with R workflows can be quite challenging. R projects frequently break when transferred between computers due to mismatched R versions or package dependencies. This white paper describes a comprehensive approach to solving this problem by combining two powerful tools: renv for R package management and Docker for containerizing the computing environment. Together, these tools ensure that an R workflow runs identically across different systems with the same packages, the package versions, R version, and system libraries as the original setup.\n#################### # edits to here 2025-05-23 08:48 # ####################"
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#executive-summary",
    "href": "posts/share_R_code_via_docker_p25/index.html#executive-summary",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "",
    "text": "Reproducibility is key to conducting professional data analysis, yet in practice, achieving it consistently with R workflows can be quite challenging. R projects frequently break when transferred between computers due to mismatched R versions or package dependencies. This white paper describes a comprehensive approach to solving this problem by combining two powerful tools: renv for R package management and Docker for containerizing the computing environment. Together, these tools ensure that an R workflow runs identically across different systems with the same packages, the package versions, R version, and system libraries as the original setup.\n#################### # edits to here 2025-05-23 08:48 # ####################"
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#motivation",
    "href": "posts/share_R_code_via_docker_p25/index.html#motivation",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "2 Motivation",
    "text": "2 Motivation\nImagine you’ve written code that you want to share with a colleague. At first glance, this may seem like a straightforward task—simply send the R files via email. However, ensuring that your colleague can run the code without errors and obtain the same results is often much more challenging than anticipated.\nWhen sharing R code, several potential problems can arise:\n\nDifferent versions of R installed on each machine\nMismatched R package versions\nMissing system dependencies (like pandoc or LaTeX)\nMissing supplemental files referenced by the program (bibliography files, LaTeX preambles, datasets, images)\nDifferent R startup configurations (.Rprofile or .Renviron)\n\nA real-world scenario often unfolds like this:\n\nYou email your R Markdown file to your colleague, Joe\nJoe attempts to run it with R -e \"source('peng1.Rmd')\"\nR isn’t installed on Joe’s system\nAfter installing R, Joe gets an error: “could not find function ‘render’”\nJoe installs the rmarkdown package\nNow pandoc is missing\nAfter installing pandoc, a required package is missing\nAfter installing the package, external files are missing (bibliography, images)\nAnd so on…\n\nThis cycle of troubleshooting can be time-consuming and frustrating, often resulting in the “it works on my machine” syndrome. Even when the code eventually runs, there’s no guarantee that Joe will get the same results that you did.\nTo ensure true reproducibility, your colleague should have a computing environment as similar to yours as possible. Given the dynamic nature of open source software, this can be difficult to achieve through manual installation and configuration.\nThe approach outlined in this white paper offers a more robust solution. Rather than sending standalone text files, you can provide a complete, containerized environment that includes everything needed to run your analysis. With this approach, your colleague can run a simple command like:\ndocker run -v \"$(pwd):/home/joe\" -v \"$(pwd)/output:/home/joe/output\" \\\nusername/penguins-analysis\nThis creates an identical R environment on their desktop, ready for them to run or modify your code with confidence that it will work as intended."
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#introduction",
    "href": "posts/share_R_code_via_docker_p25/index.html#introduction",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "3 Introduction",
    "text": "3 Introduction\n\n3.1 The Challenge of Reproducibility in R\nR has become a standard tool for data science and statistical analysis across numerous disciplines. However, as R projects grow in complexity, they often develop intricate webs of dependencies that can make sharing and reproducing analyses difficult. Some common challenges include:\n\nDifferent R versions across machines\nIncompatible package versions\nMissing system-level dependencies\nOperating system differences (macOS vs. Windows vs. Linux)\nConflicts with other installed packages\nR startup files (.Rprofile, .Renviron) that affect code behavior\n\nThese challenges often manifest as the frustrating “it works on my machine” problem, where analysis code runs perfectly for the original author but fails when others attempt to use it. This undermines the scientific and collaborative potential of R-based analyses.\n\n\n3.2 A Two-Level Solution\nTo address these challenges comprehensively, we need to tackle reproducibility at two distinct levels:\n\nPackage-level reproducibility: Ensuring exact package versions and dependencies are maintained\nSystem-level reproducibility: Guaranteeing consistent R versions, operating system, and system libraries\n\nThe strategy presented in this white paper leverages renv for package-level consistency and Docker for system-level consistency. When combined, they provide a robust framework for end-to-end reproducible R workflows."
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#renv-package-level-reproducibility",
    "href": "posts/share_R_code_via_docker_p25/index.html#renv-package-level-reproducibility",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "4 renv: Package-Level Reproducibility",
    "text": "4 renv: Package-Level Reproducibility\n\n4.1 What is renv?\nrenv (Reproducible Environment) is an R package designed to create isolated, project-specific library environments. Instead of relying on a shared system-wide R library that might change over time, renv gives each project its own separate collection of packages with specific versions.\n\n\n4.2 Key Features of renv\n\nIsolated project library: renv creates a project-specific library (typically in renv/library) containing only the packages used by that project. This isolation ensures that updates or changes to packages in one project won’t affect others.\nLockfile for dependencies: When you finish installing or updating packages, renv::snapshot() produces a renv.lock file - a JSON document listing each package and its exact version and source. This lockfile is designed to be committed to version control and shared.\nEnvironment restoration: On a new machine (or when reproducing past results), renv::restore() installs the exact versions of packages specified in the lockfile. This creates an R package environment identical to the one that created the lockfile, provided the same R version is available.\n\n\n\n4.3 Basic renv Workflow\nThe typical workflow with renv involves:\n# One-time installation of renv\ninstall.packages(\"renv\")\n\n# Initialize renv for the project\nrenv::init()  # Creates renv infrastructure\n\n# Install project-specific packages\n# ...\n\n# Save the package state to renv.lock\nrenv::snapshot()\n\n# Later or on another system...\nrenv::restore()  # Restore packages from renv.lock\nWhile renv effectively handles package dependencies, it does not address differences in R versions or system libraries. This limitation is where Docker becomes essential."
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#docker-system-level-reproducibility",
    "href": "posts/share_R_code_via_docker_p25/index.html#docker-system-level-reproducibility",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "5 Docker: System-Level Reproducibility",
    "text": "5 Docker: System-Level Reproducibility\n\n5.1 What is Docker?\nDocker is a platform that allows you to package software into standardized units called containers. A Docker container is like a lightweight virtual machine that includes everything needed to run an application: the code, runtime, system tools, libraries, and settings.\n\n\n5.2 Docker’s Role in Reproducibility\nWhile renv handles R packages, Docker ensures consistency for:\n\nOperating system: The specific Linux distribution or OS version\nR interpreter: The exact R version\nSystem libraries: Required C/C++ libraries and other dependencies\nComputational environment: Memory limits, CPU configuration, etc.\nExternal tools: pandoc, LaTeX, and other utilities needed for R Markdown\n\nBy running an R Markdown project in Docker, you eliminate differences in OS or R installation as potential sources of irreproducibility. Any machine running Docker will execute the container in an identical environment.\n\n\n5.3 Docker Components for R Workflows\nFor R-based projects, a typical Docker approach involves:\n\nBase image: Starting from a pre-configured R image (e.g., from the Rocker project)\nDependencies: Adding system and R package dependencies\nConfiguration: Setting working directories and environment variables\nContent: Adding project files\nExecution: Defining how the project should run\n\nA simple Dockerfile for an R Markdown project might look like:\n# Use R 4.1.0 on Linux as base image\nFROM rocker/r-ver:4.1.0\n\n# Set the working directory inside the container\nWORKDIR /workspace\n\n# Install renv and restore dependencies\nRUN R -e \"install.packages('renv', repos='https://cloud.r-project.org')\"\n\n# Copy renv lockfile and infrastructure\nCOPY renv.lock renv/activate.R /workspace/\n\n# Restore the R package environment\nRUN R -e \"renv::restore()\"\n\n# Default command when container runs\nCMD [\"/bin/bash\"]\nA more comprehensive Dockerfile that includes additional tools and user setup might look like:\nFROM rocker/r-devel\nRUN apt-get update && \\\n    apt-get upgrade -y && \\\n    apt-get clean\nRUN apt-get install pandoc vim git sudo -y\nRUN Rscript -e 'install.packages(\"renv\")'\nCOPY renv.lock renv.lock\nRUN Rscript -e 'renv::restore()'\nRUN groupadd --system joe\nRUN useradd --system --gid joe -m joe\nRUN usermod -aG sudo joe\nRUN chown joe:joe -R /home/joe\nRUN chown joe:joe -R /usr/local/lib/R/site-library\nWORKDIR /home/joe/\nRUN mkdir -p /home/joe/output\nUSER joe\nCMD [\"/bin/bash\"]\nThis Dockerfile creates a consistent environment with a specific R version and packages, regardless of the host system."
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#combining-renv-and-docker-a-comprehensive-approach",
    "href": "posts/share_R_code_via_docker_p25/index.html#combining-renv-and-docker-a-comprehensive-approach",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "6 Combining renv and Docker: A Comprehensive Approach",
    "text": "6 Combining renv and Docker: A Comprehensive Approach\n\n6.1 Why Use Both?\nUsing renv or Docker alone improves reproducibility, but combining them provides the most comprehensive solution:\n\nDocker guarantees the OS and R version\nrenv guarantees the R packages and their versions\nTogether they achieve end-to-end reproducibility from operating system to package dependencies\n\nThis combined approach creates a fully portable analytical environment that can be shared and will produce identical results across different computers.\n\n\n6.2 Integration Strategy\nThe recommended workflow integrates renv and Docker in the following manner:\n\nDevelop locally with renv: Create your R project with renv to manage package dependencies.\nSnapshot dependencies: Use renv::snapshot() to create a lockfile.\nContainerize with Docker: Create a Dockerfile that uses a specific R version and incorporates the renv lockfile.\nShare both: Distribute both the code (with lockfile) and the Docker configuration.\nExecute consistently: Run analyses in the Docker container for guaranteed reproducibility.\n\nThis strategy ensures that your R Markdown documents and analyses will run identically for anyone who has access to your Docker container, regardless of their local setup."
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#practical-example-collaborative-r-markdown-development-with-testing",
    "href": "posts/share_R_code_via_docker_p25/index.html#practical-example-collaborative-r-markdown-development-with-testing",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "7 Practical Example: Collaborative R Markdown Development with Testing",
    "text": "7 Practical Example: Collaborative R Markdown Development with Testing\nThe following case study demonstrates how two developers can collaborate on an R Markdown project using renv and Docker to ensure reproducibility, with integrated testing procedures to maintain code quality.\n\n7.1 Project Scenario\nTwo data scientists are collaborating on an analysis of the Palmer Penguins dataset. Developer 1 will set up the initial project structure and create a basic analysis. Developer 2 will extend the analysis with additional visualizations. They’ll use GitHub for version control and DockerHub to share the containerized environment. Both will implement testing to ensure code quality before merging changes.\n\n\n7.2 Step-by-Step Implementation\n\n7.2.1 Developer 1: Project Setup and Initial Analysis\nStep 1: Create and Initialize the GitHub Repository\nDeveloper 1 creates a new GitHub repository called “penguins-analysis” and clones it locally:\ngit clone https://github.com/username/penguins-analysis.git\ncd penguins-analysis\nStep 2: Initialize renv for Dependency Management\ninstall.packages(\"renv\")  # If not already installed\nrenv::init()  # Initialize renv for the project\nThis creates the necessary renv infrastructure, including an initial renv.lock file.\nStep 3: Install Required R Packages\ninstall.packages(\"ggplot2\")\ninstall.packages(\"palmerpenguins\")\ninstall.packages(\"testthat\")  # For testing\ninstall.packages(\"devtools\")  # For development utilities\nrenv::snapshot()  # Save package versions to renv.lock\nStep 4: Create Initial R Markdown Analysis\nDeveloper 1 creates a file named peng1.Rmd with the following content:\n\n\n\n\n\n\n---\ntitle: \"Palmer Penguins Analysis\"\nauthor: \"Developer 1\"\ndate: \"`r Sys.Date()`\"\noutput: html_document\n---\n\n```{r setup1, include=FALSE}\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n```\n\n## Flipper Length vs. Bill Length\n\n```{r flipper-bill-plot1}\nggplot(palmerpenguins::penguins, aes(x = flipper_length_mm, y = bill_length_mm)) +\n  geom_point() +\n  theme_minimal() +\n  ggtitle(\"Flipper Length vs. Bill Length\")\n```\n\n\n\nStep 5: Create Tests for Analysis Functions\nDeveloper 1 creates a test directory structure and initial tests:\nmkdir -p tests/testthat\nThen creates a file tests/testthat.R:\nlibrary(testthat)\nlibrary(palmerpenguins)\n\ntest_check(\"penguinanalysis\")\nAnd a test file tests/testthat/test-data-integrity.R:\ncontext(\"Data Integrity\")\n\ntest_that(\"penguins data is available and has expected dimensions\", {\n  expect_true(exists(\"penguins\", where = \"package:palmerpenguins\"))\n  expect_equal(ncol(palmerpenguins::penguins), 8)\n  expect_gt(nrow(palmerpenguins::penguins), 300)\n})\n\ntest_that(\"penguins data has required columns\", {\n  expect_true(\"species\" %in% names(palmerpenguins::penguins))\n  expect_true(\"bill_length_mm\" %in% names(palmerpenguins::penguins))\n  expect_true(\"flipper_length_mm\" %in% names(palmerpenguins::penguins))\n  expect_true(\"body_mass_g\" %in% names(palmerpenguins::penguins))\n})\nStep 6: Create a Dockerfile\nDeveloper 1 creates a Dockerfile that deliberately excludes the R Markdown file to ensure that Developer 2’s local files are used when running the container:\n# Use R 4.1.0 as base image\nFROM rocker/r-ver:4.1.0\n\n# Set the working directory inside the container\nWORKDIR /workspace\n\n# Install renv and restore dependencies\nRUN R -e \"install.packages('renv', repos='https://cloud.r-project.org')\"\n\n# Copy only the renv.lock and renv infrastructure\nCOPY renv.lock renv/activate.R /workspace/\n\n# Restore the R package environment\nRUN R -e \"renv::restore()\"\n\n# Create test directory\nRUN mkdir -p tests/testthat\n\nCMD [\"/bin/bash\"]\nStep 7: Build and Push the Docker Image\ndocker build -t username/penguins-analysis:v1 .\ndocker login\ndocker push username/penguins-analysis:v1\nStep 8: Run tests before committing\nDeveloper 1 runs the tests to make sure everything is working correctly:\nR -e \"devtools::test()\"\nStep 9: Commit and Push to GitHub\nAfter confirming the tests pass, Developer 1 commits the project files:\ngit add .\ngit commit -m \"Initial renv setup, Docker environment, and tests\"\ngit push origin main\nStep 10: Communicate with Developer 2\nDeveloper 1 provides these instructions to Developer 2:\n\nClone the GitHub repository\nPull the prebuilt Docker image from DockerHub\nRun the container interactively, mounting the local repository\nCreate a new branch for feature development\nExtend the analysis in the peng1.Rmd file\nWrite tests for new functionality\nRun tests to verify changes\nPush changes back to GitHub\nCreate a pull request\n\n\n\n7.2.2 Developer 2: Extending the Analysis\nStep 1: Clone the Repository and Pull the Docker Image\ngit clone https://github.com/username/penguins-analysis.git\ncd penguins-analysis\ndocker pull username/penguins-analysis:v1\nStep 2: Create a Feature Branch\ngit branch body-mass-analysis\ngit checkout body-mass-analysis\nStep 3: Run Docker Interactively\nDeveloper 2 runs the container with the local repository mounted:\ndocker run --rm -it -v \"$(pwd):/workspace\" -w /workspace username/penguins-analysis:v1 /bin/bash\nThis approach: - Uses the renv-restored environment from the container - Allows Developer 2 to access and modify files directly from their local machine\nStep 4: Extend the Analysis\nDeveloper 2 modifies peng1.Rmd to add a second plot for body mass vs. bill length:\n\n\n\n\n\n\n---\ntitle: \"Palmer Penguins Analysis\"\nauthor: \"Developer 2\"\ndate: \"`r Sys.Date()`\"\noutput: html_document\n---\n\n```{r setup2, include=FALSE}\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n```\n\n## Flipper Length vs. Bill Length\n\n```{r flipper-bill-plot2}\nggplot(palmerpenguins::penguins, \n       aes(x = flipper_length_mm, y = bill_length_mm)) +\n  geom_point() +\n  theme_minimal() +\n  ggtitle(\"Flipper Length vs. Bill Length\")\n```\n\n## Body Mass vs. Bill Length\n\n```{r mass-bill-plot}\nggplot(palmerpenguins::penguins, \n       aes(x = body_mass_g, y = bill_length_mm)) +\n  geom_point() +\n  theme_minimal() +\n  ggtitle(\"Body Mass vs. Bill Length\")\n```\n\n\n\nStep 5: Create Tests for New Analysis\nDeveloper 2 adds a new test file tests/testthat/test-body-mass-analysis.R:\ncontext(\"Body Mass Analysis\")\n\ntest_that(\"body mass data is valid\", {\n  expect_true(all(palmerpenguins::penguins$body_mass_g &gt; 0, na.rm = TRUE))\n  expect_true(is.numeric(palmerpenguins::penguins$body_mass_g))\n})\n\ntest_that(\"body mass correlates with bill length\", {\n  # Calculate correlation coefficient\n  correlation &lt;- cor(\n    palmerpenguins::penguins$body_mass_g,\n    palmerpenguins::penguins$bill_length_mm,\n    use = \"complete.obs\"\n  )\n  \n  # Verify correlation is a numeric value (not NA)\n  expect_true(!is.na(correlation))\n  \n  # Test that the correlation is positive\n  expect_true(correlation &gt; 0)\n})\nStep 6: Run Tests to Verify Changes\nBefore committing, Developer 2 runs the tests to ensure that the new code doesn’t break existing functionality and that the new analyses are working correctly:\nR -e \"devtools::test()\"\nStep 7: Commit and Push Changes Back to GitHub\nAfter confirming all tests pass, Developer 2 commits and pushes the changes:\ngit add peng1.Rmd tests/testthat/test-body-mass-analysis.R\ngit commit -m \"Added body mass vs. bill length analysis with tests\"\ngit push origin body-mass-analysis\nStep 8: Create a Pull Request\nDeveloper 2 creates a pull request on GitHub from the body-mass-analysis branch to main, describing the changes made and noting that all tests pass.\nStep 9: Code Review and Merge\nDeveloper 1 reviews the changes, checks that the tests pass in the container environment, and merges the pull request if everything looks good:\ngit checkout main\ngit pull\ndocker run --rm -v \"$(pwd):/workspace\" -w /workspace username/penguins-analysis:v1 R -e \"devtools::test()\"\n\n\n\n7.3 Continuous Integration Extension\nTo further enhance the workflow, the team could set up GitHub Actions for continuous integration, which would automatically run tests in the Docker environment whenever changes are pushed:\n# .github/workflows/r-test.yml\nname: R Tests\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    container:\n      image: username/penguins-analysis:v1\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Run tests\n      run: |\n        R -e \"devtools::test()\"\n\n\n7.4 Key Benefits Demonstrated in This Example\nThis collaborative workflow demonstrates several advantages of the renv + Docker approach with integrated testing:\n\nDependency consistency: Both developers work with identical R package versions thanks to renv.\nEnvironment consistency: The Docker container ensures the same R version and system libraries.\nCode quality: Automated tests verify that the code works as expected and catches regressions.\nSeparation of concerns: The R Markdown document remains outside the Docker image, allowing for easier collaboration.\nWorkflow flexibility: Developer 2 can work in the container while editing files locally.\nFull reproducibility: The entire analysis environment is captured and shareable.\nContinuous integration: Automated testing ensures ongoing code quality."
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#best-practices-and-considerations",
    "href": "posts/share_R_code_via_docker_p25/index.html#best-practices-and-considerations",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "8 Best Practices and Considerations",
    "text": "8 Best Practices and Considerations\n\n8.1 When to Use This Approach\nThe renv + Docker approach with testing is particularly valuable for:\n\nLong-term research projects where reproducibility over time is crucial\nCollaborative analyses with multiple contributors on different systems\nProduction analytical pipelines that need to run consistently\nAcademic publications where methods must be reproducible\nTeaching and education to ensure consistent student experiences\nComplex analyses that require rigorous testing to validate results\n\n\n\n8.2 Tips for Efficient Implementation\n\nKeep Docker images minimal: Include only what’s necessary for reproducibility.\nUse specific version tags: For both R packages and Docker base images, specify exact versions.\nDocument system requirements: Include notes on RAM and storage requirements.\nLeverage bind mounts: Mount local directories to containers for easier development.\nWrite meaningful tests: Focus on validating both data integrity and analytical results.\nAutomate testing: Use CI/CD pipelines to automatically run tests on every change.\nConsider computational requirements: Particularly for resource-intensive analyses.\n\n\n\n8.3 Testing Strategies for R Analyses\n\nData Validation Tests: Ensure data has the expected structure, types, and values.\nFunction Tests: Verify that custom functions work as expected with known inputs and outputs.\nEdge Case Tests: Check how code handles missing values, outliers, or unexpected inputs.\nIntegration Tests: Confirm that different parts of the analysis work correctly together.\nRegression Tests: Make sure new changes don’t break existing functionality.\nOutput Validation: Verify that final results match expected patterns or benchmarks.\n\n\n\n8.4 Potential Challenges\nSome challenges to be aware of:\n\nDocker image size: Images with many packages can become large\nLearning curve: Docker, renv, and testing frameworks require some initial learning\nSystem-specific features: Some analyses may rely on hardware features\nPerformance considerations: Containers may have different performance characteristics\nTest maintenance: Tests need to be updated as the analysis evolves"
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#conclusion",
    "href": "posts/share_R_code_via_docker_p25/index.html#conclusion",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "9 Conclusion",
    "text": "9 Conclusion\nAchieving full reproducibility in R requires addressing both package dependencies and system-level consistency, while ensuring code quality through testing. By combining renv for R package management, Docker for environment containerization, and automated testing for code validation, data scientists and researchers can create truly portable, reproducible, and reliable workflows.\nThe comprehensive approach presented in this white paper ensures that the common frustration of “it works on my machine” becomes a thing of the past. Instead, R Markdown projects become easy to share and fully reproducible. A collaborator or reviewer can launch the Docker container and get identical results, without worrying about package versions or system setup.\nThe case study demonstrates how two developers can effectively collaborate on an analysis while maintaining reproducibility and code quality throughout the project lifecycle. By integrating testing into the workflow, the team can be confident that their analysis is not only reproducible but also correct.\nThis strategy represents a best practice for long-term reproducibility in R, meeting the high standards required for professional data science and research documentation. By adopting this comprehensive approach, the R community can make significant strides toward the goal of fully reproducible and reliable research and analysis."
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#references",
    "href": "posts/share_R_code_via_docker_p25/index.html#references",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "10 References",
    "text": "10 References\n\nThomas, R.G. “Docker and renv strategy.”\n“Palmer Penguins Analysis.”\nThe Rocker Project. https://www.rocker-project.org/\nrenv documentation. https://rstudio.github.io/renv/\ntestthat documentation. https://testthat.r-lib.org/\nHorst, A.M., Hill, A.P., & Gorman, K.B. (2022). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R Journal."
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#prerequisites",
    "href": "posts/share_R_code_via_docker_p25/index.html#prerequisites",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "11 Prerequisites",
    "text": "11 Prerequisites\nIn development"
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#step-by-step-implementation-1",
    "href": "posts/share_R_code_via_docker_p25/index.html#step-by-step-implementation-1",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "12 Step-by-Step Implementation",
    "text": "12 Step-by-Step Implementation\nIn development"
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#key-takeaways",
    "href": "posts/share_R_code_via_docker_p25/index.html#key-takeaways",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "13 Key Takeaways",
    "text": "13 Key Takeaways\nIn development"
  },
  {
    "objectID": "posts/share_R_code_via_docker_p25/index.html#further-reading",
    "href": "posts/share_R_code_via_docker_p25/index.html#further-reading",
    "title": "Simple Process for Achieving Full Reproducibility in R: A Docker and renv Strategy",
    "section": "14 Further Reading",
    "text": "14 Further Reading\nIn development"
  }
]