{
  "hash": "e5133e163e02fcf51171caeeb1c1d504",
  "result": {
    "markdown": "---\ntitle: \"Seven step  process for securely hosting Shiny apps online\"\ndescription: \"This is the first in a series of posts offering suggested strategies for leveraging open source technologies to effectively host data science analysis results online.\"\nsubtitle: \"Github, Docker-compose, EC2 version\"\ndate: \"2022-09-18\"\ncategories: [Docker, Shiny]\nimage: \"img/rshiny.png\"\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n\n\n::: column-body\n![under construction](img/crane.jpg)\n:::\n\n<font size=\"1\"> Photo by\n<a href=\"https://unsplash.com/@nathangwaters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Nathan\nWaters</a> on\n<a href=\"https://unsplash.com/s/photos/construction?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n</font>\n\n# Introduction\n\nThis is the first in a series of posts offering suggested strategies for\nleveraging open source technologies to provide straight-forward\nsolutions to one of the central challenges in the practice of data\nscience, i.e. how to effectively communicate analysis results to clients\nand collaborators. The list of open-source technologies (or stack) we'll\nemploy is: linux, R, Shiny, Caddy, git, and Docker. We'll make use of\ntwo cloud services github and AWS.\n\nThis initial post provides a minimal, proof-of-concept example of how to\napply these technologies for hosting an interactive shiny application.\n\nWe start with a very simple, but hopefully still useful, stand-alone\nshiny app on our local workstation and push it into the cloud and end\nwith a secure (encrypted and authenticated) app running on a website\nwith a custom domain name. The approach described here is intentionally\nminimalist.\n\n# Methods\n\nTo begin, lets assume we're just finished developing a new shiny app,\nnamed `power0` . (The methods described here apply to any shiny app, but\nto provide a concrete example we've created our own app). See the code\nfor our `power0` shiny app \\[here\\] (#appendix-1) in appendix 1.\n\nWe can test the app locally by runnning it with the command (from the\n`power0` directory).\n\n``` sh\nR -e \"runApp('power0.R')\"\n```\n\nA screenshot of the finished product shows a shiny app with a widget to\nselect the sample size and a visualization (2D plot) of the power as a\nfunction of the standardized effect size:\n\n::: column-body\n![](img/shinyapppower0.png)\n:::\n\nOnce we determine the app is working as designed, we can move on to\nhosting the app on a (virtual) server to share with our collaborators.\nThere are many ways to accomplish this. Here we'll demonstrate, in a\nnutshell, in our opinion, one of the most straightforward and efficient\napproaches. That is, we'll 'spin' up a server on Amazon Web Service EC2\nand run docker containers to provide R, shiny, and caddy webserver\nfunctionality.\n\n# Hosting\n\n::: column-body\n![*Figure 1*](img/blogdockerizeflow.png)\n:::\n\nFigure 1 illustrates the tools we'll use and the flow of program and\nconfiguration files. In order to host `power0` online we'll need the\nfollowing :\n\n1.  a virtual server (connected via ssh) with firewall\n2.  a static IP address (to identify the server online)\n3.  a domain name (name for IP address)\n4.  a webserver (tool to interact with https protocol requests and\n    respond)\n5.  an SSL certificate (to allow encrypted communication)\n6.  an authentication method (password protection)\n7.  a reverse proxy method (translate https (port 443) requests to shiny\n    (port 3838)\n\nAt first glance these 7 requirements can appear daunting, but on closer\ninspection all can be met with relative ease and minimal or no cost.\n\nThis can be done at no cost if you have your own (self-hosted) server\nwith IP address, and domain name, or at minimal cost using a\ncloud-hosting service (e.g. Amazon's EC2 or Digital Ocean) and a\n\"leased\" domain name from, e.g. GoDaddy, or Amazon's Route 53.\n\n## Select a hosting service\n\nThere are a number of cloud based server options: Microsoft Azure,\nOracle, Google Cloud, Amazon AWS EC2, Digital Ocean to name a few. Each\nhas their own approach to setting up a custom virtual server. Several\nhave free or low-cost service tiers available.\n\nSpecific instructions for AWS EC2 are [here](#appendix-2) in appendix 2.\n\nOnce the server is available connect via ssh and login, The only\nnecessary software to install is docker, docker-compose and git. Install\nall 3 with the following command:\n\n``` sh\nsudo apt install -y git docker docker-compose\n```\n\nOnce the host is set up and the requisite software installedh we'll have\na customized virtual server wtih a static IP address, and unique domain\nname and firewall in place. In other words, items 1, 2, and 3 from our\nlist will be taken care of.\n\n# Website\n\nTo configure the web server and containerize our app we need to add\nthree files to the server, to go along with our shiny app in the\n`power0` directory (in the home directory for default user `ubuntu`).\n\nThe easiest way to do this is to add the three files to the power0\ndirectory on our workstation and then \"push\" a copy to github and from\nthere we can access them from our server.\n\nThese three configuation files are:\n\n-   a Caddyfile\n-   a Dockerfile\n-   a docker-compose.yml file\n\nLets discuss each. We'll use Caddy as our web server. Caddy is an\nopen-source tool that has the very useful feature of automating the\nacquiring and installing of an SSL certificate. An SSL cert is required\nto use the encrypted communication protocol https.\n\nCaddy is configured with a file named `Caddyfile`. We use the caddyfile\nto specify three critical things.\n\n1.  the site domain name.\n2.  the authentication pair login/hash-password, for each user and\n3.  the 'reverse proxy' map that redirects requests to port 443 (ssl\n    port) to port 3838 (shiny port).\n\nOur Caddyfile looks like this:\n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nrgtlab.org {\n#auth credentials: bob/utter\nbasicauth * {\n\t\tbob JDJhJDE0JElCQmRGaTA0ajY3bkZTLjRiWUZ4enVoZnVSQzVXVGVUMHlVcXJTaTRGYmpRQVFHLnYzN0tx\n\t}\n\thandle_path /power0/* {\n\t\treverse_proxy power0:3838\n\t}\n}\n```\n\n\nWe can accomplish what we need for items 4, 5 and 6 through the\nCaddyfile.\n\nNote:\n\n-   rgtlab.org is our domain name\n-   basicauth provides user login information. In this case `bob` is the\n    user\n-   name and `thebunny` is the password.\n-   `handle_path` maps all https requests to port 3838 where shiny is\n    listening.\n\nProviding our servers domain name, `rgtlab.org` is sufficient to\ninitiate an exchange with `letsencrypt` to generates an SSL certificate.\n\nThe second file is the dockerfile. In its simplest form it instructs\nDocker to build a container based on a Rocker/Shiny image which is a\nubuntu image with R and shiny installed then copy in the `power0.R` code\nand launch shiny on (default) port 3838.\n\n::: column-body\n![](img/docker1.jpg)\n:::\n\n<font size=\"1\"> Photo by\n<a href=\"https://unsplash.com/@carrier_lost?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Ian\nTaylor</a> on\n<a href=\"https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n</font>\n\nHere is our dockerfile:\n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nFROM rocker/shiny:4.2.0\nCOPY power0.R /srv/shiny-server/\nUSER shiny\nCMD [\"/usr/bin/shiny-server\"]\n```\n\n\nAnd the third file is the docker compose file that containerizes our\nshiny app, pulls a caddy webserver image from Docker Hub and creates a\nlocal network for the two containers to communicate in.\n\nThe docker-compose.yml file:\n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nversion: \"3.7\"\n\nservices:\n  power0:\n    build: .\n  caddy:\n    image: caddy:2.3.0-alpine\n    ports:\n      - \"443:443\"\n    volumes:\n      - $PWD/Caddyfile:/etc/caddy/Caddyfile\n      - caddy_data:/data\nvolumes:\n    caddy_data:\n```\n\n\nTo generate a password for say foobar.\n\n``` sh\ndocker-compose run caddy caddy hash-password foobar\n```\n\nOnce in place push the four files (power0.R, Dockerfile, Caddyfile,\ndocker-compose.yml) to github\n\n``` sh\ngit push\n\n and then login to server and clone repo.\n\n```sh\ngit clone https:// ???\n```\n\nLastly, cd to `power0` directory and run\n\n``` sh\ndocker-compose up -d\n```\n\nand you're good to go!\n\nThe app `power0` can be accessed by 'bob' at the url\n\n``` sh\nhttps://rgtlab.org/power0\n```\n\nwith password 'thebunny'\n\n# Appendix-1\n\nConsider an app that is a balance of simple and functional -- one that\ncalculates the power for a 2-sample t-test as a function of the\nstandardized effect size. re is our shiny app `power0.R`:\n\nConsider the power0.R file:\n\n``` sh\n\nui <- fluidPage(\ntitlePanel(\"Power Calculator for Two Group Parallel Designs\"),\nsliderInput(\"N\", \"Total Sample Size:\", min = 0, max = 300, value = 100),\nplotOutput(\"plot\"),\nverbatimTextOutput(\"eff\"))\n\nserver <- function(input, output, session) {\n  delta = seq(0, 1.5,.05)\n  pow = reactive(sapply(delta, function(x) power.t.test(input$N, d=x)$power ))\n  eff =  renderText(power.t.test(input$N, power=.8)$d)\n  output$plot <- renderPlot({\n  plot(delta, pow(), cex=1.5, ylab=\"power\")\n  abline(h = .8,  col = \"red\", lwd =2.5, lty = 4)\n  abline(v = eff(), col = \"blue\",lwd =2.5, lty = 4)})  \n  output$eff <- renderText(\n    paste0(\"Std. effect detectable with power 80% = \", eff()) )\n}\nshinyApp(ui, server)\n```\n\nThe app is designed to be maximally minimal. Using only base R\nfunctions, with a minimum of reactive widgets and layout commands to\nkeep it simple while still performing a useful function.\n\n# Appendix-2 {#appendix-2}\n\nAWS is a reasonable choice for setting up a small custom server. AWS\noffers a free set of servers for the first 12 months.\n\nTo start open the EC2 console.\n\n``` sh\n   https://aws.amazon.com/console\n```\n\n::: column-body\n![](img/ec2a.png)\n:::\n\nCreate an account or sign in. Next set up a working environment.\nSpecifically you'll want to set up four components of the environment:\n\n1.  Ssh key pair\n2.  Firewall\n3.  Static IP\n4.  Domain Name\n\nThe first time you create an AWS account you need to exchange an SSH key\npair with AWS. You can generate the ssh key pair locally on you\nworkstation and upload the public key to EC2. To do this create a\ndirectory to hold the keys. e.g. `~/.ssh`. From inside `.ssh` directory\nyou can generate the keys with the command\n\n``` sh\nssh-keygen -m PEM\n```\n\nin the dialog that ensues name the key prefix something like `ssh-rsa`.\n\nBack in the browser on EC2 select `security/keys`, A dialog starts and\nasks for the location of the public key. Browse to the `.ssh` directory\nand import the public key `ssh-rsa.pub`.\n\n# Set up firewall\n\nA very restrictive firewall is recommended. Only https and ssh packets\nare needed. To construct the firewall click on:\n\nFIREWALL TBD\n\n# Set up static IP address\n\nUse \"elastic IP\" to get a static IP that can be assigned to the server\n\n-   click on elastic IP in left panel\n-   select associate Elastic IP 13.57.139.31 choose an instance\n    (shiny-july22) to associate with.\n-   side panel, click \"ec2\"\n-   side panel, click \"Instances\"\n-   from top bar, click \"Launch Instances\"\n\n2.  From \"Quick Start\" click Ubuntu button.\n\n-   Name the server, say shiny-july22\n-   Choose an AMI (instance template, operating system):\n\nSuggest choose \"Ubuntu Server 22.04 LTS\", but other linux distributions\ncan be utilized, e.g.u Red Hat, or SUSE.)\n\n3.  Next choose an instance **type**, e.g. \"t2-micro\". (different\n    instance types are mixtures of size, processors, memory, instance\n    storage, network performance) click \"Next: Configure Instance\n    Details\"\n\n4.  choose Key pair (use in place aws18.pem) or set up new pair\n\n5.  Add security group, e.g. 'shiny' (sg-0f37c94ac1e1b6250) allowing\n    ports 80 (http), 22 (ssh), 443 (https), and 3838 (shiny). and 8787\n\n6.  choose 30 GB of EBS General Purpose (SSD) or Magnetic storage\n\n7.  click Launch Instance\n\nLog into new instance with ssh from local\n\n``` sh\nssh -i ~/.ssh/aws18.pem ubuntu@13.57.139.31\n```\n\n# Get Domain Name\n\nGo to godaddy.com or Amazon route 53 to associate a domain name with the\nElastic IP in EC2.\n\n(screenshot)\n\nOnce a domain name is obtained, eg rgtlab.com you want to associate it\nwith your static IP address. To associate domain name rgtlab.org with\nelastic IP in EC2 do as follows.\n\nin Route 53:\n\n-   click on 'hosted zones' in side panel\n-   click on rgtlab.org in center panel\n-   click on checkbox for rgtlab.org type=A line\n-   then click on edit record in right panel\n-   change ip address to 13.57.139.31\n\n# Appendix Tips\n\n## Tip 1.\n\nFor convenience, construct a `config` file in `~/.ssh` as:\n\n``` sh\nHost ec2\nHostName 13.57.139.31 # static IP\nUser ubuntu # default user on ubuntu server\nPort 22  # the default port ssh uses\nIdentityFile ~/.ssh/ssh-rsa\n```\n\nthen you can ssh into the new server with\n\n``` sh\nsh> ssh ec2\n```\n\n## Tip 2: Add ubuntu to the docker group to allow docker to run without sudo.\n\n# appendix x (joe data version)\n\nok! got my shiny app running. Works great! Now how do I get it up on the\nweb and shared with my client Bob?\n\nStart by creating a repo for the app on github.\n\n-   login to github (screenshot)\n\n::: column-body\n![](img/git1.png)\n:::\n\n-   click on `new` . Then in `repository name` field enter `power1`.\n    (Make the\n-   repo private, we only want to share with Bob at this point).\n-   create repo. Click `Create repository` green button at the bottom of\n    the page.\n-   back in a terminal window on your laptop: clone the repo\n\n``` sh\ngit clone https://github.com/rgt47/power1.git\n```\n\n-   Create a Dockerfile to dockerize the shiny app.\n\nThe simplist Dockerfile grabs a pre-built image (say rocker/shiny) from\nDockerhub and copies the shiny app code (app.R) to the default location\non the docker image, and then runs shiny-server. Here's the file. Copy\nit into the working directory and name it `Dockerfile`.\n\nHere is our dockerfile:\n\n\n\n```{.r .cell-code}\nFROM rocker/shiny:4.2.0\nCOPY app.R /srv/shiny-server/\nUSER shiny\nCMD [\"/usr/bin/shiny-server\"]\n```\n\n\n-   Install Docker on your laptop. Instructions here:\n    https://docs.docker.com/engine/install/\n-   Bulid and run the docker image to test it locally\n    -   docker build -t app4 .\n    -   docker run --rm -p 3838:3838 app4\n-   copy `power1.R` and `Dockerfile` from working directory `app4` to\n    the `power1` repo directory.\n\n``` sh\ncd ~/prj/app4/app.R ~/prj/app4/Dockerfile ~/prj/power1\n```\n\n-   from inside the `power1` directory, update remote repository\n    -   git add .\n    -   git commit -m 'add shiny code'\n    -   git push\n-   All good? Ok, now we need a (virtual) server to host the app. Let\n    use Amazon AWS.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}