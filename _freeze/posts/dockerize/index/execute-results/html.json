{
  "hash": "ea2a55c132a3cb831cce6c746e29740c",
  "result": {
    "markdown": "---\ntitle: \"Bare bones process to securely hosting Shiny apps online\"\ndescription: \"This is the first in a series of posts offering suggested strategies for leveraging open source technologies to effectively host data science analysis results online.\"\ndate: \"2022-09-18\"\ncategories: [Docker, Shiny]\nimage: \"img/rshiny.png\"\n---\n\n\n\n\n\n\n# Introduction\n\nThis is the first in a series of posts offering suggested strategies for\nleveraging open source  technologies to provide straight-forward  solutions to one of\nthe central challenges in the practice of data science, i.e. how to effectively\ncommunicate analysis results to clients and collaborators.  The group of\ntechnologies (or stack) we'll employ is: linux, R, Shiny, Caddy, git, and\nDocker. We'll make use of two cloud services github and AWS. \n\nThis initial post provides a minimal, proof-of-concept example of how to apply these\ntechnologies for  hosting of an interactive shiny application.  \n\nWe start with a simple, but hopefully useful, stand-alone shiny app and end with\na secure (encrypted  and authenticated) web site with a custom domain name\nhosting our app.  The approach described here is intentionally minimalist.  \n\n# Methods\n\nTo begin, lets assume we're just\nfinished developing a  new shiny app, named ``power0`` .\n\nThe methods described here apply to any shiny app, but  to provide a concrete example we've\ncreated our own app. See the code for our ``power0`` shiny app [here] (#appendix-1) in\nappendix 1. \n\nA screenshot of the finished product shows a shiny app with a widget to select the\nsample size and a visualization (2D plot) of the power as a function of the\nstandardized effect size: \n\n\n::: {.cell-output-display}\n![](img/shinyapppower0.png){width=200px}\n:::\n\n\n\n\nThe app is discussed further is [appendix 1](#appendix1)\n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nui <- fluidPage(\n  titlePanel(\"Power Calculator for Two Group \n             Parallel Designs\"),\n  sliderInput(\"N\", \"Total Sample Size:\", \n              min = 0, max = 300, value = 100),\n  plotOutput(\"plot\"),\n  verbatimTextOutput(\"eff\")\n)\n\nserver <- function(input, output, session) {\n  delta <- seq(0, 1.5, .05)\n  pow <- reactive(\n    sapply(delta,\n           function(x) power.t.test(input$N, d = x)$power\n           )\n                 )\n  eff <- renderText(power.t.test(input$N, power = .8)$d)\n  output$plot <- renderPlot({\n    plot(delta, pow(), cex = 1.5, ylab = \"power\")\n    abline(h = .8, col = \"red\", lwd = 2.5, lty = 4)\n    abline(v = eff(), col = \"blue\", lwd = 2.5, lty = 4)\n                           })\n  output$eff <- renderText(\n    paste0(\"Std. effect with power 80% = \", eff() )\n                          )\n}\nshinyApp(ui, server)\n```\n\n\nOnce we determine the app is working as designed, we are next interested in\nhosting the app on a (virtual) server to share with our collaborators. There are\nmany ways to accomplish this. Here, in a nutshell,  we'll demonstrate one of the\nmost straightforward and efficient: \"spinning\" up a server on Amazon Web Service\n(AWS) and use docker containers to provide shiny and webserver functionalityto\nprovide shiny and webserver functionality. \n\n# Hosting\n\nOnce we have a production ready  shiny app available, we'll want to\nhost it on the internet. To do that we'll need the following :\n\n1. a virtual server (connected via ssh)\n2. a static IP address (to identify the server online)\n2. a domain name (human readable name for IP address) \n2. a web server (software to recognize https protocol requests and respond)\n3. an SSL certificate (encrypted communication)\n4. an authentication method (password protection)\n5. a reverse proxy method (translate port 443 requests to port 3838 for shiny)\n5. a containerized version of app. (bundled app and requisite software) \n6. a method for ``power0`` container to communicate with containerized webserver.\n\nAt first glance these 9 requirements can appear daunting, but on closer\ninspection all can be met with minimal expertise and minimal or no cost. \n\nThis can all be done at no cost if you have your own (self-hosted) server with\nIP address, and domain name, or at minimal cost using a cloud-hosting service\n(e.g. Amazon's EC2 or Digital Ocean) and a \"leased\" domain name from, e.g.\n GoDaddy, or Amazon's Route 53. \n\n## Select a hosting service \n\nThere are a number of cloud based server options: Microsoft Azure, Google Cloud,\nAmazon AWS, Digital Ocean to name a few. Each has their own approach to setting\nup a custom virtual server.  Several have free or low-cost service tiers\navailable. \n\n\nSpecific instructions for AWS EC2 are [here](#appendix-2) in appendix 2.\n\nOnce the server is available connect via ssh, login, and Install docker,\ndocker-compose and git.\nwith the following command:\n\n```sh\nsudo apt install -y git docker docker-compose\n```\n\nOnce the hosting process is complete we'll have a customized virtual server wtih\na static IP address and unique domain name and firewall in place. In other\nwords, items 1, 2, and 3 will be taken care of. \n\n# Website\n\n\nTo configure the web server and containerize our app we need to add three\n files to the server, to go along with our shiny app in the `power0`\ndirectory (in the home directory for default user `ubuntu`). \n\nThe easiest way to do this is to add the three files to the power0 directory on\nour workstation and then \"push\" a copy to github. \n\n\n\nThese three configuation files are:\n\n* a Caddyfile\n* a Dockerfile\n* a docker-compose.yml file\n\nLets discuss each and initially add them to the power0 directory on our workstation. \nOnce the three files are in place in the directory we can push copies to github and from there\nwe can access them from our server.\n\nWe'll use Caddy as our web server. Caddy is an open-source tool that has the\nvery useful feature of  automating the acquiring and installing of an SSL\ncertificate, which is required to use the encrypted communication protocol https. \n\n\nCaddy is configured with a file named  `Caddyfile`.  The\ncaddyfile configures three things.  \n\n1. the site domain name. \n2. the authentication pair login/hash-password, and \n3. the 'reverse proxy' map that\n   redirects requests to port 443 (ssl port) to port 3838 (shiny port). \n\nThe Caddyfile in our example is:\n\n\nauth info bob/utter\n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nrgtlab.org {\n#auth credentials: bob/utter\nbasicauth * {\n\t\tbob JDJhJDE0JElCQmRGaTA0ajY3bkZTLjRiWUZ4enVoZnVSQzVXVGVUMHlVcXJTaTRGYmpRQVFHLnYzN0tx\n\t}\n\thandle_path /power0/* {\n\t\treverse_proxy power0:3838\n\t}\n}\n```\n\nWe can accomplish what we need for items 4, 5\nand 6 through the Caddyfile. \n\nFor your project replace: \n\n* rgtlab.org with your domain name\n* Bob JDJ... with user names and hash-passwords \n* power0 with you app's name\n\nProviding  our servers domain name, `rgtlab.org` is\nsufficient to initiate an exchange with `letsencrypt` to\ngenerates an SSL certificate. \n\n\nThe second file is the dockerfile. In its simplest form it instructs Docker to build\na container based on a Rocker/Shiny image then copy in the app.R code and\nlaunch shiny on (default) port 3838. \n\n\n::: {.cell-output-display}\n![](img/docker1.jpg){width=150px}\n:::\n\n<font size=\"2\"> \nPhoto by <a href=\"https://unsplash.com/@carrier_lost?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Ian Taylor</a> on <a href=\"https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n</font> \n\nHere is our dockerfile: \n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nFROM rocker/shiny:4.2.0\nCOPY app.R /srv/shiny-server/\nUSER shiny\nCMD [\"/usr/bin/shiny-server\"]\n```\n\n\n\nAnd the third file is the docker compose file that containerizes our shiny app,\nand pulls a caddy server image from Docker Hub and create a local network for\nthe two containers to communicate in.\n\nThe docker-compose.yml file:\n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nversion: \"3.7\"\n\nservices:\n  power0:\n    build: .\n  caddy:\n    image: caddy:2.3.0-alpine\n    ports:\n      - \"443:443\"\n    volumes:\n      - $PWD/Caddyfile:/etc/caddy/Caddyfile\n      - caddy_data:/data\nvolumes:\n    caddy_data:\n```\n\n\nTo generate a password for say foobar. \n\n```sh\t\ndocker-compose run caddy caddy hash-password foobar\n\n```\n\nOnce in place push power0 to github and then clone repo to server.\n\nLets clone them into the server from github. \n\n```sh\ngit clone https:// ???\n```\n\ncd to power0 directory and run\n\n```sh\ndocker-compose up -d\n```\n\nand you're good to go!\nThe app `power0` can be accessed by 'bob' at the url\n```sh\nhttps://rgtlab.org/power0\n```\nwith password 'utter'\n\n# Appendix-1 \n\nConsider an app that is a balance of simple and functional -- one that calculates\nthe power for a 2-sample t-test as a function of the standardized effect size. \nre is our shiny app `power0.R`: \n\nConsider the power0.R file:  \n\n```sh\n\nui <- fluidPage(\ntitlePanel(\"Power Calculator for Two Group Parallel Designs\"),\nsliderInput(\"N\", \"Total Sample Size:\", min = 0, max = 300, value = 100),\nplotOutput(\"plot\"),\nverbatimTextOutput(\"eff\"))\n\nserver <- function(input, output, session) {\n  delta = seq(0, 1.5,.05)\n  pow = reactive(sapply(delta, function(x) power.t.test(input$N, d=x)$power ))\n  eff =  renderText(power.t.test(input$N, power=.8)$d)\n  output$plot <- renderPlot({\n  plot(delta, pow(), cex=1.5, ylab=\"power\")\n  abline(h = .8,  col = \"red\", lwd =2.5, lty = 4)\n  abline(v = eff(), col = \"blue\",lwd =2.5, lty = 4)})  \n  output$eff <- renderText(\n    paste0(\"Std. effect detectable with power 80% = \", eff()) )\n}\nshinyApp(ui, server)\n\n```\n\nThe app is designed to be maximally minimal. Using only base R functions, with a\nminimum of reactive widgets and layout commands to keep it simple while still\nperforming a useful function. \n\n# Appendix-2 \n\n\nAWS is a reasonable choice for setting up a small custom server. AWS offers a\nfree set of servers for the first 12 months. \n\n\nTo start open the EC2 console. \n```sh\n   https://aws.amazon.com/console\n```\n\n\n::: {.cell-output-display}\n![](img/ec2a.png){width=300px}\n:::\n\n\nCreate an account or sign in. Next set up a working environment. Specifically\nyou'll want to set up four components of the environment:\n\n1. Ssh key pair\n1. Firewall \n1. Static IP\n1. Domain Name \n\nThe first time you create an AWS account you need to exchange an SSH key pair\nwith AWS.  You can generate the ssh key pair locally on you workstation and\nupload the public key to EC2. \n\nCreate a directory to hold the keys. e.g. `~/.ssh`. Change directory into\n`.ssh`.\n Generate the keys with the command\n\n```sh\nssh-keygen -m PEM\n```\nname the key prefix something like `ssh-rsa`.\n\nOn EC2 select `security/keys`, browse to the `.ssh` directory and  import the\npublic key `ssh-rsa.pub`.\n\nFor convenience, construct a `config` file in `~/.ssh` as:\n```sh\nHost ec2\nHostName 13.57.139.31 # static IP\nUser ubuntu # default user on ubuntu server\nPort 22  # the default port ssh uses\nIdentityFile ~/.ssh/ssh-rsa\n```\nthen you can ssh into the new server with \n```sh\nsh> ssh ec2\n```\n\n\nUse \"elastic IP\" to get a static IP that can be assigned to the server\n\n* click on elastic IP in left panel\n* select associate Elastic IP  13.57.139.31\n  choose an instance (shiny-july22) to associate with. \n* side panel, click \"ec2\"\n* side panel, click \"Instances\"\n* from top bar, click \"Launch Instances\"\n\n2. From \"Quick Start\" click Ubuntu button. \n* Name the server, say shiny-july22\n* Choose an AMI (instance template, operating system):\n\nSuggest choose \"Ubuntu Server 22.04 LTS\", but other linux distributions can be utilized, e.g.u \nRed Hat, or SUSE.)\n\n\n3. Next choose an instance **type**, e.g. \"t2-micro\". (different instance types are\n   mixtures of size, processors, memory, instance storage, network performance) \nclick \"Next: Configure Instance Details\"\n\n4. choose Key pair (use in place aws18.pem) or set up new pair\n\n\n5. Add security group, e.g. 'shiny' (sg-0f37c94ac1e1b6250) \nallowing ports 80 (http), 22 (ssh), 443 (https), and 3838 (shiny). \nand 8787 \n\n6. choose  30 GB of EBS General Purpose (SSD) or Magnetic storage   \n\n7. click Launch Instance\n\n\n\nLog into new instance with ssh from local\n\n```sh\nssh -i ~/.ssh/aws18.pem ubuntu@13.57.139.31\n```\nor \n```sh\nssh ec2 \n\n```\nif you've set up a ``config`` file in ``~/.ssh`` \n\n\nTip: Add ubuntu to the docker group to allow docker to run without sudo. \n\n\nGo to godaddy or Amazon route 53 to associate a domain name with the Elastic IP\nin EC2. \n\n(screenshot) \n\nTo associate domain name rgtlab.org with elastic IP.\n\nin Route 53: \n\n* click on 'hosted zones' in side panel\n* click on rgtlab.org in center panel\n* click on checkbox for rgtlab.org type=A line\n* then click on edit record in right panel\n* change ip address to 13.57.139.31\n\n\n\n# appendix x (joe data version)\n\nok! got my shiny app running. Works great! Now how do I get it up on the web and\nshared with my client Bob?  \n\nStart by creating a repo for the app on github. \n\n* login to github (screenshot) \n\n\n\n::: {.cell-output-display}\n![](img/git1.png){width=300px}\n:::\n\n\n\n*  click  on `new` in `repo name` and enter `power1`. (Make the repo private we\n  only want to share with Bob at this point). \n* create repo\n* on workstation: clone the repo \n```sh\ngit clone https://github.com/rgt47/power1.git\n```\n* copy `power1.R` in `power1` repo directory. \n* update remote repo\n    * git add . \n    * git commit -m 'add shiny code'\n    * git push\n\nNow we need a (virtual) server to host the app. Let use Amazon AWS. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}