{
  "hash": "d1be6cd33db034575a768bc7e715bb13",
  "result": {
    "markdown": "---\ntitle: \"\nWriting a simple R package in S3. \"\ndescription: \"Getting started with S3 OO programming in R\"\ncategories: [AWS]\nimage: \"img/oop.png\"\ndate: last-modified\n#format:\n#  pdf:\n#    toc: true\n---\n\n\n\n::: column-margin\n![S3 OOP in R](img/oop.png)\n:::\n\n# Introduction\n\nIf you, like me, feel its time to expand your  R programming armamentarium  to\ninclude  S3 methods. This blog may help. Where to start? \n\nLet's begin by reading the relevant chapters in Advanced R (add reference). \n\nAlso useful other references: \n\nIntroduction to Scientific Programming and Simulation using R. Jomes.\nMaillardet, Robinson. \n\n[1608.07161] A Simple Guide to S3 Methods https://arxiv.org/abs/1608.07161\n\nWhy your S3 method isn't working | R-bloggers\n\nDealing with S3 methods in R with a simple example | R-bloggers\n\nVideo on S3 Classes in R by Dr Andrew Robinson | R-bloggers\n\nUnexported S3 Methods and R Packages | R-bloggers\n\nSimple Guide to S3 Methods | R-bloggers\n\nThe S3 OOP system | R-bloggers\n\n\nS3 methods allow coders to write functions that perform differently for\ndifferent classes of objects. \n\nIn our project we want to build a function that creates a row in the 'Table 1'\ntable for each factor in the formula regardless of the mode of the factor. \n\n7/1/23\nNow reading Nick Tierney R journal paper. \n\n# Appendix zz.table1.c\n\n::: {.cell}\n\n```{.r .cell-code}\nzz.table1.c = function(df, form, pv=TRUE, totl=TRUE, grps=TRUE) {\nif (!require(\"pacman\")) install.packages(\"pacman\", repo=\"cran.rstudio.com\")\npacman::p_load(janitor )\nprep = \tfunction(df, form) {\ndfr = df %>%  \n    ungroup %>% \n    sel(all.vars(form[[3]])) \ndf_list = dfr %>%  split( df_grp) %>%  \nlist_merge(., \"Total\" = dfr) %>%  \npurrr::transpose()\n}\nprocess1 = function(x){\npv_chr = data.frame(x[[\"Total\"]],df_grp) %>%\npvalue_chr \nll = x[[length(x)]]%>%  as.factor %>% levels \nll_indent = paste(\"\\\\hspace{5mm}   \",ll)\nsum_chr = x %>% \n    lapply(function(x) factor(x, levels=ll)) %>%  \t\n    map(categ)   %>% as_tibble  %>% \n    cbind(variable=ll_indent, ., 'p-value'=NA) %>% \n    mut(variable=as.character(variable)) %>% \n    rbind(NA, .) \nsum_chr[1,ncol(sum_chr)]=pv_chr\n# browser()\nreturn(sum_chr)\n}\nprocess2 = function(x){\npv_num = data.frame(x[[\"Total\"]],df_grp) %>%    \n   pvalue_num\nsum_num = x %>% \n   map_chr(contin)  %>% \n   bind_rows  %>%  \n   cbind(variable=NA,., 'p-value'=pv_num)    %>%  \n   mut(variable=as.character(variable)) \nreturn(sum_num)\n}\ncontin= function(x) {\ns1 = zz.sum.min(x)\npaste0(s1['Mean'],\"$\\\\pm$\", s1['SD'], \" ({\\\\scriptsize $\",s1['N'],\"$})\") }\ncateg = function(x) {\nprps = table(x) %>% prop.table  %>%  round(2)*100\ncnts_prps =  table(x)%>% \npaste0(.,\" ({\\\\scriptsize $\",prps,\"$})\")\n} \npvalue_num = function(df) {\ntidy(anova(lm(as.formula(paste(names(df),  collapse=\"~\")), data = df)))$p.value[1]\n}\npvalue_chr = function(df) {\ntab =  table(df[,1], df[,2])\nifelse((nrow(tab) >=2 & ncol(tab) >=2), \n       stats::fisher.test(tab,simulate.p.value=T)$p.value, NA) \n}\nfieldclass =sapply(df, class)%>%  enframe %>%  \nslice(match(all.vars(form[[3]]),name))\ngroupclass =sapply(df, class)%>%  enframe %>%  \nslice(match(all.vars(form[[2]]),name))\ndf_grp<- df %>%  pull(groupclass$name)\ndf2 = prep(df, form)\nout = df2 %>%  \n  map_if(fieldclass$value==\"numeric\" | fieldclass$value==\"integer\", function(x){process2(x)}) %>%  \n       map_if(fieldclass$value==\"character\", function(x){process1(x)})\t %>%  \nimap(function(x,y) {\n         y2 = ifelse(fieldclass$value[fieldclass$name == y]==\"character\", \n\t\t     paste(y, \"-- {\\\\scriptsize no. (\\\\%)}\"), y)\n\t x[1,1]=y2\n#  browser()\n\t x\n       }) %>%  \n   bind_rows()\non= names(out)\nnn = tabyl(df_grp)%>% \n    adorn_totals() %>% \n    pull(n)\t\nnames(out) = paste(rep(\"{\\\\bf\",length(on)),on, c(\"\",paste0(\"\\\\scriptsize(n=\",nn,\")\"),\"\"),rep(\"}\",length(on)))\nif (!grps) out = out %>%  sel(contains(\"variable\"),contains(\"Total\"),contains(\"p-value\"))\nif (!pv) {\n\tout = out %>%  sel(-contains(\"p-value\"))}\nif (!totl) out = out %>%  sel(-contains(\"Total\"))\nreturn(out)\n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}