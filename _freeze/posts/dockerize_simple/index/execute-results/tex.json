{
  "hash": "3fa5cec406571f75457601aae6e7ef89",
  "result": {
    "markdown": "---\ntitle: \"A simple process to get your  Shiny app online (securely). \"\ndescription: \"This is the first in a series of posts offering suggested strategies for leveraging open source technologies to effectively host data science analysis apps and reports online.\"\ncategories: [Docker, Shiny]\nimage: \"img/rshiny.png\"\ndate: last-modified\n---\n\n\n\n::: column-margin\n![under construction](img/crane.jpg)\n<font size=\"1\"> Photo by\n<a href=\"https://unsplash.com/@nathangwaters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Nathan\nWaters</a> on\n<a href=\"https://unsplash.com/s/photos/construction?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n</font>\n:::\n\n\n# Introduction\n\nThis is another in a series of posts suggesting straightforward, open-source strategies\nto effectively communicate data analysis results to clients and collaborators. \n\nIn this\npost we propose a simple method to migrate a shiny app from your local\nworkstation to the web. \n\nThe list of open-source technologies (software stack) we\nsuggest is: linux, R, Shiny, Docker, and Caddy. In this post we'll\nmake use of the AWS  cloud service. In future posts we'll describe alternate\ncloud constructions, e.g. using the low cost cloud service: Hetzner.\n\nIn the following we'll provide a proof-of-concept example of how to\napply these technologies for securely hosting an interactive Shiny application\non the web.\n\nWe start with a very simple, but hopefully still useful, stand-alone Shiny app\ndeveloped on our local workstation.    After some interfacing with the Amazon\nweb service environment, we'll push the Shiny app into the cloud, configure a\nweb server, and end up with a secure (encrypted and authenticated) app running\non a website with a custom domain name. \n\n# Methods\n\nTo begin, lets assume we're just finished developing a new Shiny app, named\n`power1_shiny`. We have a working directory named `power1_app`. Inside\n`power1_app` `power1_shiny` is a sub-directory containing the shiny program file\n`app.R `.\n\nThe methods described here apply generically to any Shiny app.  See the\n`R/Shiny` code for our `power1_shiny` app (`app.R`) below.\n\nOur shiny app is designed to be a balance of simple and functional, it\ncalculates the power for a 2-sample t-test as a function of the standardized\neffect size. The app is intentionally minimal; using only base R functions, with\na minimum of reactive widgets and layout commands. \n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"show the `power1_shiny/app.R` code\"}\nui <- fluidPage(\ntitlePanel(\"Power Calculator for Two Group Parallel Designs\"),\nsliderInput(\"N\", \"Total Sample Size:\", min = 0, max = 300, value = 100),\nplotOutput(\"plot\"),\nverbatimTextOutput(\"eff\"))\n\nserver <- function(input, output, session) {\n  delta = seq(0, 1.5,.05)\n  pow = reactive(sapply(delta, function(x) power.t.test(input$N, d=x)$power ))\n  eff =  renderText(power.t.test(input$N, power=.8)$d)\n  output$plot <- renderPlot({\n  plot(delta, pow(), cex=1.5, ylab=\"power\")\n  abline(h = .8,  col = \"red\", lwd =2.5, lty = 4)\n  abline(v = eff(), col = \"blue\",lwd =2.5, lty = 4)})  \n  output$eff <- renderText(\n    paste0(\"Std. effect detectable with power 80% = \", eff()) )\n}\nshinyApp(ui, server)\n```\n\n\nWe can test the app locally on our workstation by runnning it with the following command\nissued from the `power1_app` directory shell prompt  \n\n``` sh\nzsh> R -e \"library(shiny); runApp('power1_shiny/app.R', launch=T)\"\n```\n\nThis will, in sequence, start the R\nprogram, load the Shiny package, run and launch the app in your default browser.\n\nThe  Figure   shows our Shiny app running locally in a browser on our\ndesktop, it consists of a widget to select the sample size and a plot to provide a dynamic\nvisualization  of the power as a function of the standardized\neffect size.\n\n::: column-margin\n![*Shiny app*](img/shinyapppower1.png)\n:::\n\nOnce we determine our app is working as designed, we move on to the task of\nhosting the app on a (virtual) server with the goal of sharing with our\ncollaborators. There are a number of ways to accomplish this. Here we'll\ndescribe one approach as to how to  'spin up' a server on Amazon Web Service EC2\nand in just a few steps, through the application of Docker, R, Shiny, and Caddy\nhave a secure web app running on the web.\n\n# Hosting\n\nIn order to host `power1_shiny` online we'll need to complete the\nfollowing tasks:\n\n1. obtain a static IP address \n3.  obtain a domain name \n1.  create a virtual server with a firewall\n4.  install and configure a webserver \n5.  obtain and install an SSL certificate \n6.  setup an authentication method\n   and\n7.  configure a reverse proxy method to translate https (port 443) requests to Shiny\n    (port 3838).\n\nAt first glance these 7 requirements can appear daunting, but on closer\ninspection all can be met with relative ease and minimal  cost ( using a\ncloud-hosting service, e.g. Amazon's EC2 or Digital Ocean, and a\n\"leased\" domain name from, e.g. GoDaddy, or Amazon's Route 53)\nor at no cost if you have your own  server with IP address, and domain name.\n\n## Select a hosting service \n\nThere are a number of cloud based server options: Microsoft Azure, Oracle,\nGoogle Cloud, Amazon AWS EC2, Digital Ocean and Hetzner to name a few. Each has\ntheir own approach to setting up a custom virtual server. Several have free or\nlow-cost service tiers available.\n\nAn overview of the process with AWS EC2  follows. (Detailed\ninstructions for AWS EC2 were described in an earlier post:\n[here](https://focusonr.org/posts/setupaws)\n\nPreface. create an AWS account or sign in and navigate to the EC2 dashboard. \n\nstep 1. Set up an working environment with AWS server.\n\na. define secure shell (ssh) key-pair \nb. configure firewall.\nc. obtain static IP.\nd. obtain domain name. \n\nOnce the environment is set up\n\nstep 2. Config and launch server\n\na. select instance operating system (`ubuntu`) and type (`t2-micro`) \nb. launch server\n\nOnce the server is available  connect via ssh. \n\n```sh\nssh -i \"~/.ssh/power1_app_ssh.pem\"  ubuntu@rgtlab.org\n```\n\nor using the `config` setup described in Tip 1 at the end of this post.\n```sh\nssh rgtlab.org \n```\n\nThe only necessary software tools to install are Docker and Caddy. If you\nfollowed the CLI  or console based instructions to set up a virtual server\n[here](https://focusonr.org/posts/server_setup_aws_cli/index.pdf) or\n[here](https://focusonr.org/posts/server_setup_aws_console/) Docker and Caddy\nwill be pre-installed. \n\nOtherwise you can install\nthem  with the following commands:\n\n``` sh\nsudo apt update\nsudo apt install docker.io -y\nsudo apt install -y curl debian-keyring debian-archive-keyring apt-transport-https\ncurl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | \\\nsudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg\ncurl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | \\\nsudo tee /etc/apt/sources.list.d/caddy-stable.list\nsudo apt update\nsudo apt install caddy -y\n```\n\n\n\nAt this point we have\na customized virtual server with a static IP address, unique domain\nname and firewall in place. In other words, items 1, 2, and 3 from our\n'hosting' list above are taken care of.\n\n\n## Website\n\nTo containerize our Shiny app we need a Dockerfile to the `power1_app` directory.\n\n\n\nThe three configuation files are:\n\n1.   a Docker configuration file (default name `Dockerfile`)\n\n::: column-margin\n![](img/docker1.jpg)\n<font size=\"1\"> Photo by\n<a href=\"https://unsplash.com/@carrier_lost?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Ian\nTaylor</a> on\n<a href=\"https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n</font>\n:::\n\nWe'll use docker to access  R/Shiny.  Here is our minimal dockerfile:\n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"`Dockerfile`: Show the code\"}\nFROM rocker/shiny:4.2.0\nCOPY /power1_shiny/* /srv/shiny-server/\nCMD [\"/usr/bin/shiny-server\"]\n```\n\n\n This  file instructs Docker\nto build a container based on a Rocker/Shiny image (which is a ubuntu\nimage with R and Shiny installed) then copy into the container the\n`power1_shiny` directory containing the shiny code and\nfinally launch Shiny server listening on (default) port 3838. We placed the `power1_shiny/app.R` code in the\ndefault location `/srv/shiny-server` so we only need to start the server and it\nwill find the shiny program. \n\nTo configure the web server we need to add\na Caddy configuration file (default name `Caddyfile`) to the \n`power1_app` directory.  \n\n We'll use `Caddy` as our web server. Caddy is an\nopen-source tool that has the very useful feature of automating the\nacquiring and installing of an SSL certificate. (An SSL cert is required\nby most browsers to use the encrypted communication protocol `https`.)\n\nCaddy is configured with a file named `Caddyfile`. We use the caddy\nconfiguration file to specify three critical things.\n\n1.  the site domain name.\n2.  the authentication pair login/hash-password, for each user and\n3.  the 'reverse proxy' map that redirects requests to port 443 (ssl\n    port) onto port 3838 (Shiny port) in the docker container.\n\nOur barebones Caddyfile looks like this:\n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"`Caddyfile`: Show the code\"}\nrgtlab.org {\n    basicauth * /power1_shiny/* {\n\t\tbob $2a$14$pYWd5O7JqNeGLS4m4CKkzemM2pq5ezn9bcTDowofZTl5wRVl8NTJm\n\t}\n    root * /var/www/html\n    handle_path /power1_shiny/* {\n            reverse_proxy 0.0.0.0:3838\n    }\n    file_server\n}\n```\n\n\nWe can accomplish what we need for items 4, 5, 6 and 7 through the\nCaddyfile.\n\nNote:\n\n-   rgtlab.org is our domain name\n-   the basicauth directive specifies login credentials for bob (password:\n    vanilla47)\n-   `handle_path` maps all https requests to port 3838 where Shiny is\n    listening.\n-   `root` directive tells Caddy where to look for the `index.html` file. \n\nProviding our servers domain name, `rgtlab.org` is sufficient to\ninitiate an exchange with the `letsencrypt` service to generates an SSL certificate.\n\nLastly, we need a  `index.html` file to provide a launch page for the app.\nand move all files to the server.\n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"`index.html`: Show the code\"}\n<!DOCTYPE html>\n<html>\n  <body>\n    <h1>Power1 app</h1>\n    <ul>\n      <li><a href=\"./power1_shiny/\">Power1 app</a></li>\n    </ul>\n  </body>\n</html> \n```\n\n\nOnce the  config files and the index.html file and the Shiny code directory are\nin place copy the `power1_app` directory to the server `rgtlab.org`  with the\nsecure copy command: \n\n```sh\nscp -i \"~/.ssh/power1_app.pem\" -r ~/prj/power1_app/  ubuntu@rgtlab.org:~\n```\n\nLastly, ssh to the server and cd to `power1_app` directory\n\nBuild and run the Docker container. Using the docker approach allows us\nto avoid installing both R and Shiny on the virtual server `rgtlab.org`\n\n```sh\ndocker build -t power1_image .\n```\ncreate container and run\n```sh\ndocker run -d --name=power1_shiny -p 3838:3838 --restart=always power1_image\n```\n\n\ncopy `Caddyfile` to location caddy expects\n in `/etc/caddy` directory\n\n```sh\nsudo cp ./Caddyfile /etc/caddy/Caddyfile \n```\n\ncopy `index.html` to location caddy expects\n in `/var/www/html` directory\n```sh\ncp  ./index.html /var/www/html/index.html \n```\n\n\nand run the following command to \n\n\nrestart Caddy\n```sh\nsudo systemctl reload caddy\n```\n\nApp launch page is now available at `https://rgtlab.org`.\n\nand you're good to go!\n\n## Tip construct ssh config file. \nFor convenience, construct a `config` file in `~/.ssh` as:\n\n``` sh\nHost rgtlab.org\nHostName 13.57.139.31 # static IP\nStrictHostKeyChecking no  #avoid known host file error message\nUser ubuntu # default user on ubuntu server\nPort 22  # the default port ssh uses\nIdentityFile ~/.ssh/power1_app.pem\n```\n\nthen you can ssh into the new server with\n\n``` sh\nsh> ssh rgtlab.org \n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}