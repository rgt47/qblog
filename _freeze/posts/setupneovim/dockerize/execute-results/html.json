{
  "hash": "bc931e67bb88694b24c304071da5c8da",
  "result": {
    "markdown": "---\ntitle: \"Seven step  process for securely hosting Shiny apps online\"\ndescription: \"This is the first in a series of posts offering suggested strategies for leveraging open source technologies to effectively host data science analysis results online.\"\nsubtitle: \"Github, Docker-compose, EC2 version\"\ndate: \"2022-09-18\"\ncategories: [Docker, Shiny]\nimage: \"img/rshiny.png\"\n---\n\n\n\n:::{.column-body}\n![under construction](img/crane.jpg)\n:::\n\n<font size=\"1\"> \nPhoto by <a href=\"https://unsplash.com/@nathangwaters?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Nathan Waters</a> on <a href=\"https://unsplash.com/s/photos/construction?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n</font> \n  \n\n# Introduction\n\nThis is the first in a series of posts offering suggested strategies for\nleveraging open source  technologies to provide straight-forward  solutions to\none of the central challenges in the practice of data science, i.e. how to\neffectively communicate analysis results to clients and collaborators.  The list\nof open-source technologies (or stack) we'll employ is: linux, R, Shiny, Caddy,\ngit, and Docker. We'll make use of two cloud services github and AWS. \n\nThis initial post provides a minimal, proof-of-concept example of how to apply these\ntechnologies for  hosting  an interactive shiny application.  \n\nWe start with a very simple, but hopefully still useful, stand-alone shiny app\non our local workstation and push it into the cloud and end with a secure\n(encrypted  and authenticated) app running on a website with a custom domain\nname.  The approach described here is intentionally minimalist.  \n\n# Methods\n\nTo begin, lets assume we're just\nfinished developing a  new shiny app, named ``power0`` .\n(The methods described here apply to any shiny app, but  to provide a concrete example we've\ncreated our own app). \nSee the code for our ``power0`` shiny app [here] (#appendix-1) in\nappendix 1. \n\nWe can test the app locally by runnning it with the command  (from the ``power0`` directory). \n\n```sh\nR -e \"runApp('power0.R')\"\n```\n\nA screenshot of the finished product shows a shiny app with a widget to select the\nsample size and a visualization (2D plot) of the power as a function of the\nstandardized effect size: \n\n:::{.column-body}\n![](img/shinyapppower0.png)\n:::\n\n\n\n\nOnce we determine the app is working as designed, we can move on to\nhosting the app on a (virtual) server to share with our collaborators. There are\nmany ways to accomplish this. Here  we'll demonstrate, in a nutshell, in our\nopinion, one of the\nmost straightforward and efficient approaches. That is, we'll 'spin' up a server\non Amazon Web Service EC2\nand run docker containers to provide R, shiny, and caddy webserver functionality. \n\n# Hosting\n\n:::{.column-body}\n![*Figure 1*](img/blogdockerizeflow.png)\n:::\n\n\nFigure 1 illustrates the tools we'll use and the flow of program and\nconfiguration files. In order  to host ``power0`` online we'll need the following :\n\n1. a virtual server (connected via ssh) with firewall\n2. a static IP address (to identify the server online)\n2. a domain name (name for IP address) \n2. a webserver (tool to interact with https protocol requests and respond)\n3. an SSL certificate (to allow encrypted communication)\n4. an authentication method (password protection)\n5. a reverse proxy method (translate https (port 443) requests to shiny (port 3838)\n\nAt first glance these 7 requirements can appear daunting, but on closer\ninspection all can be met with relative ease and minimal or no cost. \n\nThis can be done at no cost if you have your own (self-hosted) server with\nIP address, and domain name, or at minimal cost using a cloud-hosting service\n(e.g. Amazon's EC2 or Digital Ocean) and a \"leased\" domain name from, e.g.\n GoDaddy, or Amazon's Route 53. \n\n## Select a hosting service \n\nThere are a number of cloud based server options: Microsoft Azure, Oracle, Google Cloud,\nAmazon AWS EC2, Digital Ocean to name a few. Each has their own approach to setting\nup a custom virtual server.  Several have free or low-cost service tiers\navailable. \n\n\nSpecific instructions for AWS EC2 are [here](#appendix-2) in appendix 2.\n\nOnce the server is available connect via ssh and login, The only necessary\nsoftware to install is  docker, docker-compose and git.\nInstall all 3 with the following command:\n\n```sh\nsudo apt install -y git docker docker-compose\n```\n\nOnce the host is set up and the requisite software installedh we'll have a customized virtual server wtih\na static IP address, and unique domain name and firewall in place. In other\nwords, items 1, 2, and 3 from our list will be taken care of. \n\n# Website\n\n\nTo configure the web server and containerize our app we need to add three\n files to the server, to go along with our shiny app in the `power0`\ndirectory (in the home directory for default user `ubuntu`). \n\nThe easiest way to do this is to add the three files to the power0 directory on\nour workstation and then \"push\" a copy to github and from there\nwe can access them from our server.\n\nThese three configuation files are:\n\n* a Caddyfile\n* a Dockerfile\n* a docker-compose.yml file\n\nLets discuss each. We'll use Caddy as our web server. Caddy is an open-source\ntool that has the very useful feature of  automating the acquiring and\ninstalling of an SSL certificate. An SSL cert is required to use the encrypted\ncommunication protocol https. \n\n\nCaddy is configured with a file named  `Caddyfile`.  We use the\ncaddyfile to specify three critical things.  \n\n1. the site domain name. \n2. the authentication pair login/hash-password, for each user and \n3. the 'reverse proxy' map that\n   redirects requests to port 443 (ssl port) to port 3838 (shiny port). \n\nOur Caddyfile looks like this:\n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nrgtlab.org {\n#auth credentials: bob/utter\nbasicauth * {\n\t\tbob JDJhJDE0JElCQmRGaTA0ajY3bkZTLjRiWUZ4enVoZnVSQzVXVGVUMHlVcXJTaTRGYmpRQVFHLnYzN0tx\n\t}\n\thandle_path /power0/* {\n\t\treverse_proxy power0:3838\n\t}\n}\n```\n\nWe can accomplish what we need for items 4, 5 and 6 through the Caddyfile. \n\nNote: \n\n* rgtlab.org is our domain name\n* basicauth provides user login information. In this case ``bob`` is the user\n* name and ``thebunny`` is the password. \n* ``handle_path`` maps all https requests to port 3838 where shiny is listening. \n\nProviding  our servers domain name, `rgtlab.org` is\nsufficient to initiate an exchange with `letsencrypt` to\ngenerates an SSL certificate. \n\n\nThe second file is the dockerfile. In its simplest form it instructs Docker to build\na container based on a Rocker/Shiny image which is a ubuntu image with R and\nshiny installed then copy in the ``power0.R`` code and\nlaunch shiny on (default) port 3838. \n\n:::{.column-body}\n![](img/docker1.jpg)\n:::\n\n<font size=\"1\"> \nPhoto by <a href=\"https://unsplash.com/@carrier_lost?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Ian Taylor</a> on <a href=\"https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>\n</font> \n\nHere is our dockerfile: \n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nFROM rocker/shiny:4.2.0\nCOPY power0.R /srv/shiny-server/\nUSER shiny\nCMD [\"/usr/bin/shiny-server\"]\n```\n\n\n\nAnd the third file is the docker compose file that containerizes our shiny app,\npulls a caddy webserver image from Docker Hub and creates a local network for\nthe two containers to communicate in.\n\nThe docker-compose.yml file:\n\n\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nversion: \"3.7\"\n\nservices:\n  power0:\n    build: .\n  caddy:\n    image: caddy:2.3.0-alpine\n    ports:\n      - \"443:443\"\n    volumes:\n      - $PWD/Caddyfile:/etc/caddy/Caddyfile\n      - caddy_data:/data\nvolumes:\n    caddy_data:\n```\n\n\nTo generate a password for say foobar. \n\n```sh\t\ndocker-compose run caddy caddy hash-password foobar\n\n```\n\nOnce in place push the four files (power0.R, Dockerfile, Caddyfile,\ndocker-compose.yml) to github\n\n```sh\ngit push\n\n and then login to server and clone repo.\n\n```sh\ngit clone https:// ???\n```\n\nLastly, cd to ``power0`` directory and run\n\n```sh\ndocker-compose up -d\n```\n\nand you're good to go!\n\nThe app `power0` can be accessed by 'bob' at the url\n```sh\nhttps://rgtlab.org/power0\n```\nwith password 'thebunny'\n\n# Appendix-1 \n\nConsider an app that is a balance of simple and functional -- one that calculates\nthe power for a 2-sample t-test as a function of the standardized effect size. \nre is our shiny app `power0.R`: \n\nConsider the power0.R file:  \n\n```sh\n\nui <- fluidPage(\ntitlePanel(\"Power Calculator for Two Group Parallel Designs\"),\nsliderInput(\"N\", \"Total Sample Size:\", min = 0, max = 300, value = 100),\nplotOutput(\"plot\"),\nverbatimTextOutput(\"eff\"))\n\nserver <- function(input, output, session) {\n  delta = seq(0, 1.5,.05)\n  pow = reactive(sapply(delta, function(x) power.t.test(input$N, d=x)$power ))\n  eff =  renderText(power.t.test(input$N, power=.8)$d)\n  output$plot <- renderPlot({\n  plot(delta, pow(), cex=1.5, ylab=\"power\")\n  abline(h = .8,  col = \"red\", lwd =2.5, lty = 4)\n  abline(v = eff(), col = \"blue\",lwd =2.5, lty = 4)})  \n  output$eff <- renderText(\n    paste0(\"Std. effect detectable with power 80% = \", eff()) )\n}\nshinyApp(ui, server)\n\n```\n\nThe app is designed to be maximally minimal. Using only base R functions, with a\nminimum of reactive widgets and layout commands to keep it simple while still\nperforming a useful function. \n\n# Appendix-2 \n\n\nAWS is a reasonable choice for setting up a small custom server. AWS offers a\nfree set of servers for the first 12 months. \n\n\nTo start open the EC2 console. \n```sh\n   https://aws.amazon.com/console\n```\n\n:::{.column-body}\n![](img/ec2a.png)\n:::\n\nCreate an account or sign in. Next set up a working environment. Specifically\nyou'll want to set up four components of the environment:\n\n1. Ssh key pair\n1. Firewall \n1. Static IP\n1. Domain Name \n\nThe first time you create an AWS account you need to exchange an SSH key pair\nwith AWS.  You can generate the ssh key pair locally on you workstation and\nupload the public key to EC2.  To do this create a directory to hold the keys.\ne.g. `~/.ssh`. From inside `.ssh` directory you can  generate the keys with the command\n\n```sh\nssh-keygen -m PEM\n```\nin the dialog that ensues name the key prefix something like `ssh-rsa`.\n\nBack in the browser on EC2 select `security/keys`, A dialog starts and asks for\nthe location of the public key. Browse to the `.ssh` directory and  import the\npublic key `ssh-rsa.pub`.\n\n# Set up firewall\n\nA very restrictive firewall is recommended. Only https and ssh packets are\nneeded. To construct the firewall click on: \n\nFIREWALL TBD\n\n# Set up static IP address\n\nUse \"elastic IP\" to get a static IP that can be assigned to the server\n\n* click on elastic IP in left panel\n* select associate Elastic IP  13.57.139.31\n  choose an instance (shiny-july22) to associate with. \n* side panel, click \"ec2\"\n* side panel, click \"Instances\"\n* from top bar, click \"Launch Instances\"\n\n2. From \"Quick Start\" click Ubuntu button. \n* Name the server, say shiny-july22\n* Choose an AMI (instance template, operating system):\n\nSuggest choose \"Ubuntu Server 22.04 LTS\", but other linux distributions can be utilized, e.g.u \nRed Hat, or SUSE.)\n\n\n3. Next choose an instance **type**, e.g. \"t2-micro\". (different instance types are\n   mixtures of size, processors, memory, instance storage, network performance) \nclick \"Next: Configure Instance Details\"\n\n4. choose Key pair (use in place aws18.pem) or set up new pair\n\n\n5. Add security group, e.g. 'shiny' (sg-0f37c94ac1e1b6250) \nallowing ports 80 (http), 22 (ssh), 443 (https), and 3838 (shiny). \nand 8787 \n\n6. choose  30 GB of EBS General Purpose (SSD) or Magnetic storage   \n\n7. click Launch Instance\n\n\n\nLog into new instance with ssh from local\n\n```sh\nssh -i ~/.ssh/aws18.pem ubuntu@13.57.139.31\n```\n\n\n# Get Domain Name\n\nGo to godaddy.com or Amazon route 53 to associate a domain name with the Elastic IP\nin EC2. \n\n(screenshot) \n\nOnce a domain name is obtained, eg rgtlab.com you want to associate it with your\nstatic IP address. To associate domain name rgtlab.org with elastic IP in EC2\ndo as follows.\n\nin Route 53: \n\n* click on 'hosted zones' in side panel\n* click on rgtlab.org in center panel\n* click on checkbox for rgtlab.org type=A line\n* then click on edit record in right panel\n* change ip address to 13.57.139.31\n\n# Appendix Tips\n\n## Tip 1. \n\nFor convenience, construct a `config` file in `~/.ssh` as:\n\n```sh\nHost ec2\nHostName 13.57.139.31 # static IP\nUser ubuntu # default user on ubuntu server\nPort 22  # the default port ssh uses\nIdentityFile ~/.ssh/ssh-rsa\n```\nthen you can ssh into the new server with \n```sh\nsh> ssh ec2\n```\n\n## Tip 2: Add ubuntu to the docker group to allow docker to run without sudo. \n\n# appendix x (joe data version)\n\nok! got my shiny app running. Works great! Now how do I get it up on the web and\nshared with my client Bob?  \n\nStart by creating a repo for the app on github. \n\n* login to github (screenshot) \n\n:::{.column-body}\n![](img/git1.png)\n:::\n\n\n*  click  on `new` . Then in `repository name` field enter `power1`. (Make the\n*  repo private,  we \n  only want to share with Bob at this point). \n* create repo. Click ``Create repository`` green button at the bottom of the page. \n* back in a terminal window on your laptop: clone the repo \n```sh\ngit clone https://github.com/rgt47/power1.git\n```\n\n\n* Create a Dockerfile to dockerize the shiny app. \n\nThe simplist Dockerfile grabs a pre-built image (say rocker/shiny) from\nDockerhub and copies the shiny app code (app.R) to the default location on the\ndocker image, and then runs shiny-server. Here's the file. Copy it into the\nworking directory and name it ``Dockerfile``.  \n\nHere is our dockerfile: \n\n\n\n```{.r .cell-code}\nFROM rocker/shiny:4.2.0\nCOPY app.R /srv/shiny-server/\nUSER shiny\nCMD [\"/usr/bin/shiny-server\"]\n```\n\n\n* Install Docker on your laptop. Instructions here: https://docs.docker.com/engine/install/\n* Bulid and run the docker image to test it locally \n    * docker build -t app4 .\n    * docker run --rm -p 3838:3838 app4 \n\n\n* copy `power1.R` and ``Dockerfile`` from working directory ``app4`` to the  `power1` repo directory. \n```sh\ncd ~/prj/app4/app.R ~/prj/app4/Dockerfile ~/prj/power1\n```\n\n* from inside the ``power1`` directory, update remote repository\n    * git add . \n    * git commit -m 'add shiny code'\n    * git push\n\n* All good? Ok, now we need a (virtual) server to host the app. Let use Amazon AWS. \n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}